#!/usr/bin/env python3
"""Shell completion scripts generator for Code Navigator.

Generates bash and zsh completion scripts that provide autocompletion
for codenav commands and symbol names from the code map.

Example:
    # Generate bash completion
    $ codenav completion bash > ~/.bash_completion.d/codenav

    # Generate zsh completion
    $ codenav completion zsh > ~/.zfunc/_codenav

    # Source directly (bash)
    $ eval "$(codenav completion bash)"
"""

import json
from typing import List

__version__ = "1.3.0"

BASH_COMPLETION_TEMPLATE = """# Bash completion for codenav
# Generated by code-navigator

_codenav_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="map search read stats completion watch export"
    local map_opts="-o --output -i --ignore --incremental --git-only --use-gitignore --compact --no-color -h --help"
    local search_opts="-m --map -t --type -f --file --files --structure --deps --stats --check-stale --warn-stale --since-commit -l --limit --no-fuzzy --compact -o --output --no-color -h --help"
    local read_opts="-c --context --symbol -r --root --compact -o --output --no-color -h --help"
    local export_opts="-m --map -f --format -o --output --no-color -h --help"
    local watch_opts="-o --output -i --ignore --git-only --use-gitignore --compact --no-color --debounce -h --help"
    local completion_opts="bash zsh"
    local types="function class method interface struct trait enum type"

    case "${cword}" in
        1)
            COMPREPLY=($(compgen -W "${commands}" -- "${cur}"))
            return
            ;;
    esac

    case "${words[1]}" in
        map)
            if [[ "${cur}" == -* ]]; then
                COMPREPLY=($(compgen -W "${map_opts}" -- "${cur}"))
            else
                _filedir -d
            fi
            ;;
        search)
            case "${prev}" in
                -t|--type)
                    COMPREPLY=($(compgen -W "${types}" -- "${cur}"))
                    ;;
                -m|--map)
                    _filedir json
                    ;;
                -o|--output)
                    COMPREPLY=($(compgen -W "json table" -- "${cur}"))
                    ;;
                *)
                    if [[ "${cur}" == -* ]]; then
                        COMPREPLY=($(compgen -W "${search_opts}" -- "${cur}"))
                    else
                        # Try to complete symbol names from codenav
                        _codenav_complete_symbols
                    fi
                    ;;
            esac
            ;;
        read)
            if [[ "${cur}" == -* ]]; then
                COMPREPLY=($(compgen -W "${read_opts}" -- "${cur}"))
            else
                _filedir
            fi
            ;;
        stats)
            if [[ "${cur}" == -* ]]; then
                COMPREPLY=($(compgen -W "-m --map --compact -o --output --no-color -h --help" -- "${cur}"))
            fi
            ;;
        completion)
            COMPREPLY=($(compgen -W "${completion_opts}" -- "${cur}"))
            ;;
        watch)
            if [[ "${cur}" == -* ]]; then
                COMPREPLY=($(compgen -W "${watch_opts}" -- "${cur}"))
            else
                _filedir -d
            fi
            ;;
        export)
            case "${prev}" in
                -f|--format)
                    COMPREPLY=($(compgen -W "markdown html graphviz" -- "${cur}"))
                    ;;
                -m|--map)
                    _filedir json
                    ;;
                -o|--output)
                    _filedir
                    ;;
                *)
                    if [[ "${cur}" == -* ]]; then
                        COMPREPLY=($(compgen -W "${export_opts}" -- "${cur}"))
                    fi
                    ;;
            esac
            ;;
    esac
}

_codenav_complete_symbols() {
    # Try to read symbols from .codenav.json in current directory
    local mapfile=".codenav.json"
    if [[ -f "${mapfile}" ]]; then
        local symbols=$(python3 -c "
import json
try:
    with open('${mapfile}') as f:
        data = json.load(f)
    symbols = set()
    for file_info in data.get('files', {}).values():
        for sym in file_info.get('symbols', []):
            symbols.add(sym['name'])
    print(' '.join(sorted(symbols)[:50]))
except (OSError, json.JSONDecodeError, KeyError, TypeError):
    pass
" 2>/dev/null)
        COMPREPLY=($(compgen -W "${symbols}" -- "${cur}"))
    fi
}

complete -F _codenav_completions codenav
"""

ZSH_COMPLETION_TEMPLATE = """#compdef codenav
# Zsh completion for codenav
# Generated by code-navigator

_codenav() {
    local -a commands
    commands=(
        'map:Generate a code map of a codebase'
        'search:Search for symbols in the code map'
        'read:Read specific lines from files'
        'stats:Show codebase statistics'
        'completion:Generate shell completion script'
        'watch:Watch for changes and auto-update map'
        'export:Export code map to different formats'
    )

    local -a types
    types=(function class method interface struct trait enum type)

    local -a formats
    formats=(markdown html graphviz)

    _arguments -C \\
        '1:command:->command' \\
        '*::arg:->args'

    case "$state" in
        command)
            _describe -t commands 'codenav command' commands
            ;;
        args)
            case "$words[1]" in
                map)
                    _arguments \\
                        '1:path:_files -/' \\
                        '-o[Output file path]:file:_files' \\
                        '--output[Output file path]:file:_files' \\
                        '*-i[Patterns to ignore]:pattern:' \\
                        '*--ignore[Patterns to ignore]:pattern:' \\
                        '--incremental[Only update changed files]' \\
                        '--git-only[Only scan git-tracked files]' \\
                        '--use-gitignore[Use .gitignore patterns]' \\
                        '--compact[Output compact JSON]' \\
                        '--no-color[Disable colored output]' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                search)
                    _arguments \\
                        '1:query:_codenav_symbols' \\
                        '-m[Path to code map]:file:_files -g "*.json"' \\
                        '--map[Path to code map]:file:_files -g "*.json"' \\
                        '-t[Filter by symbol type]:type:(${types})' \\
                        '--type[Filter by symbol type]:type:(${types})' \\
                        '-f[Filter by file pattern]:pattern:' \\
                        '--file[Filter by file pattern]:pattern:' \\
                        '--files[Search for files instead of symbols]' \\
                        '--structure[Show structure of a file]:file:_files' \\
                        '--deps[Show dependencies of a symbol]:symbol:_codenav_symbols' \\
                        '--stats[Show codebase statistics]' \\
                        '--check-stale[Check if files have changed]' \\
                        '--warn-stale[Warn if files are stale]' \\
                        '--since-commit[Show changes since commit]:commit:' \\
                        '-l[Maximum results]:number:' \\
                        '--limit[Maximum results]:number:' \\
                        '--no-fuzzy[Disable fuzzy matching]' \\
                        '--compact[Output compact JSON]' \\
                        '-o[Output format]:format:(json table)' \\
                        '--output[Output format]:format:(json table)' \\
                        '--no-color[Disable colored output]' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                read)
                    _arguments \\
                        '1:file:_files' \\
                        '2:lines:' \\
                        '-c[Context lines]:number:' \\
                        '--context[Context lines]:number:' \\
                        '--symbol[Read entire symbol]' \\
                        '-r[Root path]:path:_files -/' \\
                        '--root[Root path]:path:_files -/' \\
                        '--compact[Output compact JSON]' \\
                        '-o[Output format]:format:(json code)' \\
                        '--output[Output format]:format:(json code)' \\
                        '--no-color[Disable colored output]' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                stats)
                    _arguments \\
                        '-m[Path to code map]:file:_files -g "*.json"' \\
                        '--map[Path to code map]:file:_files -g "*.json"' \\
                        '--compact[Output compact JSON]' \\
                        '-o[Output format]:format:(json table)' \\
                        '--output[Output format]:format:(json table)' \\
                        '--no-color[Disable colored output]' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                completion)
                    _arguments '1:shell:(bash zsh)'
                    ;;
                watch)
                    _arguments \\
                        '1:path:_files -/' \\
                        '-o[Output file path]:file:_files' \\
                        '--output[Output file path]:file:_files' \\
                        '*-i[Patterns to ignore]:pattern:' \\
                        '*--ignore[Patterns to ignore]:pattern:' \\
                        '--git-only[Only scan git-tracked files]' \\
                        '--use-gitignore[Use .gitignore patterns]' \\
                        '--compact[Output compact JSON]' \\
                        '--no-color[Disable colored output]' \\
                        '--debounce[Debounce time in seconds]:seconds:' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
                export)
                    _arguments \\
                        '-m[Path to code map]:file:_files -g "*.json"' \\
                        '--map[Path to code map]:file:_files -g "*.json"' \\
                        '-f[Export format]:format:(${formats})' \\
                        '--format[Export format]:format:(${formats})' \\
                        '-o[Output file]:file:_files' \\
                        '--output[Output file]:file:_files' \\
                        '--no-color[Disable colored output]' \\
                        '(-h --help)'{-h,--help}'[Show help]'
                    ;;
            esac
            ;;
    esac
}

_codenav_symbols() {
    local mapfile=".codenav.json"
    if [[ -f "$mapfile" ]]; then
        local -a symbols
        symbols=(${(f)"$(python3 -c "
import json
try:
    with open('$mapfile') as f:
        data = json.load(f)
    symbols = set()
    for file_info in data.get('files', {}).values():
        for sym in file_info.get('symbols', []):
            symbols.add(sym['name'])
    print('\\n'.join(sorted(symbols)[:100]))
except (OSError, json.JSONDecodeError, KeyError, TypeError):
    pass
" 2>/dev/null)"})
        _describe -t symbols 'symbol' symbols
    fi
}

_codenav "$@"
"""


def generate_bash_completion() -> str:
    """Generate bash completion script.

    Returns:
        Bash completion script as a string.
    """
    return BASH_COMPLETION_TEMPLATE


def generate_zsh_completion() -> str:
    """Generate zsh completion script.

    Returns:
        Zsh completion script as a string.
    """
    return ZSH_COMPLETION_TEMPLATE


def get_symbols_from_map(map_path: str, limit: int = 100) -> List[str]:
    """Extract symbol names from a code map for completion.

    Args:
        map_path: Path to the .codenav.json file.
        limit: Maximum number of symbols to return.

    Returns:
        List of symbol names.
    """
    try:
        with open(map_path, encoding="utf-8") as f:
            data = json.load(f)

        symbols = set()
        for file_info in data.get("files", {}).values():
            for sym in file_info.get("symbols", []):
                symbols.add(sym["name"])
                if len(symbols) >= limit:
                    break
            if len(symbols) >= limit:
                break

        return sorted(symbols)[:limit]
    except Exception:
        return []


def run_completion(shell: str) -> None:
    """Generate and print completion script for the specified shell.

    Args:
        shell: Shell type ('bash' or 'zsh').
    """
    if shell == "bash":
        print(generate_bash_completion())
    elif shell == "zsh":
        print(generate_zsh_completion())
    else:
        print(f"Unknown shell: {shell}. Supported: bash, zsh", file=__import__("sys").stderr)
        __import__("sys").exit(1)
